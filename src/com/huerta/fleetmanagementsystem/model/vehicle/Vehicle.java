package com.huerta.fleetmanagementsystem.model.vehicle;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import com.huerta.fleetmanagementsystem.interfaces.Assignable;
import com.huerta.fleetmanagementsystem.interfaces.Calculable;
import com.huerta.fleetmanagementsystem.interfaces.Maintainable;
import com.huerta.fleetmanagementsystem.interfaces.Reportable;
import com.huerta.fleetmanagementsystem.model.component.BreakingSystem;
import com.huerta.fleetmanagementsystem.model.component.Engine;
import com.huerta.fleetmanagementsystem.model.component.Transmission;
import com.huerta.fleetmanagementsystem.model.maintenance.MaintenanceRecord;
import com.huerta.fleetmanagementsystem.model.person.Driver;

import lombok.Getter;

/**
 * Abstract base class for every vehicle in the fleet.
 *
 * <p><b>OOP concept – Abstraction:</b> {@code Vehicle} is declared
 * {@code abstract} and cannot be instantiated directly. It defines
 * common state and behaviour, while forcing subclasses to provide a
 * concrete {@link #calculateOperatingCost()} implementation.</p>
 *
 * <p><b>OOP concept – Hierarchy (Inheritance):</b> concrete types
 * ({@link Car}, {@link Motorcycle}) extend {@code Vehicle} directly,
 * while {@link HeavyVehicle} introduces an intermediate layer for
 * weight-related concerns, further extended by {@link Bus} and
 * {@link Truck}.</p>
 *
 * <p><b>OOP concept – Polymorphism:</b> methods such as
 * {@link #calculateOperatingCost()}, {@link #generateReport()} and
 * {@link #calculateDepreciation()} are dispatched dynamically at
 * runtime depending on the actual subclass.</p>
 *
 * <p><b>OOP concept – Composition:</b> a vehicle <em>owns</em> its
 * {@link Engine}, {@link Transmission} and {@link BreakingSystem}
 * components — they are created in the constructor and share the
 * vehicle’s lifecycle.</p>
 *
 * <p><b>OOP concept – Encapsulation:</b> all fields are {@code private}
 * with validated setters; getters are generated by Lombok
 * ({@code @Getter}).</p>
 *
 * <p><b>OOP concept – Upcasting:</b> any concrete vehicle (e.g.
 * {@code new Car(...)}) can be stored as a {@code Vehicle} reference,
 * enabling polymorphic collections such as {@code List<Vehicle>}.</p>
 *
 * @see HeavyVehicle
 * @see Car
 * @see Motorcycle
 */
@Getter
public abstract class Vehicle implements Assignable, Calculable, Maintainable, Reportable {

  /** Kilometres per depreciation block used in the mileage-based formula. */
  private static final double MILEAGE_BLOCK_KM = 10000.0;

  /** Depreciation fraction charged per {@link #MILEAGE_BLOCK_KM} (1 %). */
  private static final double DEPRECIATION_PER_MILEAGE_BLOCK = 0.01;

  /** Unique numeric identifier (≥ 0). */
  private long id;

  /** Official licence-plate string. */
  private String licensePlate;

  /** Manufacturer / brand name. */
  private String make;

  /** Model name. */
  private String model;

  /** Manufacturing year (1886–next year). */
  private int year;

  /** Total kilometres travelled (≥ 0). */
  private double mileage;

  /** Original purchase price. */
  private double purchasePrice;

  /** Currently assigned driver (may be {@code null}). Aggregation. */
  private Driver driver;

  /** History of maintenance events. Aggregation of records. */
  private List<MaintenanceRecord> maintenanceRecords;

  /** Engine component. <b>Composition</b> — created and owned by this vehicle. */
  private Engine engine;

  /** Transmission component. <b>Composition</b> — created and owned by this vehicle. */
  private Transmission transmission;

  /** Braking-system component. <b>Composition</b> — created and owned by this vehicle. */
  private BreakingSystem breakingSystem;

  /**
   * Default no-arg constructor.
   */
  public Vehicle() {
  }

  /**
   * Creates a vehicle with the given identity and basic attributes.
   * Component objects ({@link Engine}, {@link Transmission},
   * {@link BreakingSystem}) are instantiated here (<b>composition</b>).
   *
   * @param id           unique identifier (≥ 0)
   * @param licensePlate licence plate; must not be blank
   * @param make         manufacturer; must not be blank
   * @param model        model name; must not be blank
   * @param year         manufacturing year (1886–next year)
   * @param mileage      total kilometres (≥ 0)
   * @throws IllegalArgumentException if any argument is invalid
   */
  public Vehicle(long id, String licensePlate, String make, String model, int year, double mileage) {
    setId(id);
    setLicensePlate(licensePlate);
    setMake(make);
    setModel(model);
    setYear(year);
    setMileage(mileage);
    this.engine = new Engine();
    this.transmission = new Transmission();
    this.breakingSystem = new BreakingSystem();
    this.maintenanceRecords = new ArrayList<>();
  }

  /**
   * Sets the vehicle identifier.
   *
   * @param id must be ≥ 0
   * @throws IllegalArgumentException if negative
   */
  public void setId(long id) {
    if (id < 0) {
      throw new IllegalArgumentException("ID cannot be negative.");
    }
    this.id = id;
  }

  /**
   * Sets the licence plate.
   *
   * @param licensePlate non-{@code null}, non-blank plate
   * @throws IllegalArgumentException if null or blank
   */
  public void setLicensePlate(String licensePlate) {
    if (licensePlate == null || licensePlate.isBlank()) {
      throw new IllegalArgumentException("License plate cannot be null or empty.");
    }
    this.licensePlate = licensePlate;
  }

  /**
   * Sets the manufacturer name.
   *
   * @param make non-{@code null}, non-blank manufacturer
   * @throws IllegalArgumentException if null or blank
   */
  public void setMake(String make) {
    if (make == null || make.isBlank()) {
      throw new IllegalArgumentException("Make cannot be null or empty.");
    }
    this.make = make;
  }

  /**
   * Sets the model name.
   *
   * @param model non-{@code null}, non-blank model
   * @throws IllegalArgumentException if null or blank
   */
  public void setModel(String model) {
    if (model == null || model.isBlank()) {
      throw new IllegalArgumentException("Model cannot be null or empty.");
    }
    this.model = model;
  }

  /**
   * Sets the manufacturing year.
   *
   * @param year must be between 1886 and next year (inclusive)
   * @throws IllegalArgumentException if out of range
   */
  public void setYear(int year) {
    if (year < 1886 || year > java.time.Year.now().getValue() + 1) {
      throw new IllegalArgumentException("Year must be between 1886 and next year.");
    }
    this.year = year;
  }

  /**
   * Sets the total mileage.
   *
   * @param mileage kilometres travelled; must be ≥ 0
   * @throws IllegalArgumentException if negative
   */
  public void setMileage(double mileage) {
    if (mileage < 0) {
      throw new IllegalArgumentException("Mileage cannot be negative.");
    }
    this.mileage = mileage;
  }

  /** {@inheritDoc} */
  @Override
  public void registerMaintenance(MaintenanceRecord maintenanceRecord) {
    if (maintenanceRecord != null) {
      this.maintenanceRecords.add(maintenanceRecord);
    }
  }

  /** {@inheritDoc} */
  @Override
  public String generateReport() {
    String driverName = "No Driver";
    if (this.driver != null && this.driver.getFullName() != null && !this.driver.getFullName().isBlank()) {
      driverName = this.driver.getFullName();
    }

    return String.format(
        "Vehicle Report%nLicense Plate: %s%nMake: %s%nModel: %s%nYear: %d%nDriver: %s",
        this.licensePlate,
        this.make,
        this.model,
        this.year,
        driverName);
  }

  /** {@inheritDoc} */
  @Override
  public void assignDriver(Driver driver) {
    if (driver != null) {
      this.driver = driver;
    }

  }

  /** {@inheritDoc} */
  @Override
  public void releaseDriver() {
    if (this.driver == null) {
      return;
    }
    this.driver = null;

  }

  /** {@inheritDoc} */
  @Override
  public List<MaintenanceRecord> getMaintenanceHistory() {
    return Collections.unmodifiableList(this.maintenanceRecords);
  }

  /**
   * {@inheritDoc}
   *
   * <p>Formula: 10 % per year of age + 1 % per 10 000 km, capped at 90 %.</p>
   */
  @Override
  public double calculateDepreciation() {
    // based depreciation 10% per year
    // plus 1% per 10,000 km

    int currentYear = java.time.Year.now().getValue();
    int age = currentYear - this.year;

    double ageDepreciation = age * 0.10; // 10% per year
    double mileageDepreciation = (this.mileage / MILEAGE_BLOCK_KM) * DEPRECIATION_PER_MILEAGE_BLOCK; // 1% per 10k km

    double totalDepreciation = ageDepreciation + mileageDepreciation;

    // Cap at 90%
    return Math.min(totalDepreciation, 0.90);
  }

  /** {@inheritDoc} */
  @Override
  public String toString() {
    return String.format("%s [%s] - %s %s (%d)",
        getClass().getSimpleName(), licensePlate, make, model, year);
  }

  /**
   * Calculates the operating cost specific to this vehicle type.
   *
   * <p><b>OOP concept – Polymorphism:</b> each concrete subclass
   * provides its own formula; the JVM selects the correct implementation
   * at runtime via <b>dynamic dispatch</b>.</p>
   *
   * @return operating cost in monetary units
   */
  public abstract double calculateOperatingCost();
}
